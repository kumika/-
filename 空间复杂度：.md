# 空间复杂度：

定义：

---

似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。
    空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\"进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。
如**当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)**；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量


**算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的公式是S(n)=O(f(n)),n是问题规模，f(n)是关于n的存储空间的函数。
一般情况下，一个程序在机器上执行时，除了存储本身需要的指令、常量、变量和输入数据以外，还需要一些对数据进行操作的辅助存储空间。其中，对于输入数据所占用的具体存储量取决于问题本身，与算法无关，这样只需要分析该算法在实现时所需要的辅助空间单元个数即可。**

算法1：

    for(i=0;i<n;i++){
        b[i]=a[n-i-1];
    }
    for(i=0;i<n;i++){
        a[i]=b[i]
    }

算法2：

    for(i=0;i<n/2;i++){
        t=a[i];
        a[i]=a[n-i-1];
        a[n-i-1]=t;
    }

算法1的空间复杂度为O(n),需要一个大小为n的辅助数组b。
算法2的空间复杂度为O(1),需要一个变量t，与问题规模无关


想使一个算法既占用存储空间少，又运行时间短，在现实中是很难做到的，要节约算法的执行时间往往要牺牲更多空间作为代价，而为了节省空间可能要消耗更多的计算时间，因此，具体的情况要看具体的需求来分析。

#简单解释
----

https://blog.csdn.net/qq_29503203/article/details/52464306
空间复杂度
空间复杂度，它是对一个算法在运行过程中临时占用存储空间大小的量度。所以它强调的是

> 使用的辅助空间的的大小，而不是指所有的数据所占用的空间。

要注意的是**递归算法的空间复杂度**，假如**递归深度**为N*每次递归的辅助空间大小，如果每次递归的辅助空间为常数，则空间复杂度为O(N)。

由于大部分算法的空间复杂度问题并不严重，并且算法的空间复杂度分析方法和算法的时间复杂度分析方法基本相同，所以一般数据结构只讨论算法的时间复杂度，不讨论算法的空间复杂度

下面通过斐波那契数列对时间，空间复杂度进行分析一下：

    1.	long long* fib(long long n)  
    2.	{  
    3.	    assert(n>=0);  
    4.	    long long* ptr=new long long[n+1];  
    5.	    ptr[0]=0;  
    6.	    ptr[1]=1;  
    7.	    for(int i=2;i<=n;++i)  
    8.	    {  
    9.	        ptr[i]=ptr[i-1]+ptr[i-2];  
    10.	    }  
    11.	    return ptr;  
    12.	}

对于这种算法，函数真正执行次数为n-1,所以忽略常数后，时间复杂度为O(n);
因为开辟了n+1个空间，有n+1个辅助空间，所以空间复杂度为O(n).




    1.	long long fib(long long n)  
    2.	{  
    3.	    assert(n>=0);  
    4.	    long long first=0;  
    5.	    long long second=1;  
    6.	    long long ret=0;  
    7.	        for(int i=2;i<=n;i++)  
    8.	    {  
    9.	        ret=first+second;  
    10.	        first=second;  
    11.	        second=ret;  
    12.	    }  
    13.	    return ret;  
    14.	} 

这是非递归的另一种算法，函数真正执行次数依然为n-1,所以忽略常数后，时间复杂度还是O(n);
由于采用变量交换的方式，所以在这里辅助空间个数为一个常数，空间复杂度为O(1).


再看一下递归算法

    1.	#include<assert.h>  
    2.	#include<iostream>  
    3.	using namespace std;  
    4.	long long fib(long long n)  
    5.	{  
    6.	    assert(n>=0);  
    7.	    return (n<2)?(n):(fib(n-1)+fib(n-2));  
    8.	}  
    9.	int main()  
    10.	{  
    11.	        long long value=fib(15);  
    12.	    cout<< value <<endl;  
    13.	    system("pause");  
    14.	    return 0;  
    15.	}  

递归算法的时间复杂度计算方法是:递归总次数*每次递归次数；
递归算法的空间复杂度计算方法是：递归深度*每次递归所需的辅助空间个数.

最早斐波那契研究该数列时，为了描述清楚就以兔子生长情况为例：
.第一个月有一对刚诞生的兔子；
.第二个月后可生育；
.每月每对可生育的兔子会诞生下一对新兔子；
.假设兔子永不死去。

空间1.1
![空间1.1][1]
由上图可以得出斐波那契递归算法时间复杂度：O（2^N），空间复杂度为:O(N)


下面再看一个有关二分查找的的例子：
递归情况

    1.	int BinarySearch2(const int* ptr,const int x,const int left,const int right)  
    2.	{  
    3.	    int mid=(left+right)/2;  
    4.	    while(left<=right)  
    5.	    {  
    6.	        if(x<ptr[mid])  
    7.	        {  
    8.	            return BinarySearch2(ptr,x,left,mid-1);  
    9.	        }  
    10.	        else if(x>ptr[mid])  
    11.	        {  
    12.	            return BinarySearch2(ptr,x,mid+1,right);  
    13.	        }  
    14.	        return mid;  
    15.	    }  
    16.	} 

1)假设以最坏情况考虑，二分查找第一次在n/2中查找(n为元素个数)；第二次在一半的一半中查找，即n/2/2=n/4;
**……第x次在n/2^x范围内查找，即2^x=n(x=log2^n),所以时间复杂度为O(log2^n).
2)递归情况下的空间复杂度：递归深度为N*每次递归的辅助空间大小，如果每次递归的辅助空间为常数，则空间复杂度为O(N)。
对于递归的二分查找，递归深度是log2^n，每次递归的辅助空间为常数，所以空间复杂度为O(log2^N)**

非递归情况

    1.	int BinarySearch1(const int* ptr,const int x,const int len)  
    2.	{  
    3.	    int left=0;  
    4.	    int right=len-1;  
    5.	    int mid=(left+right)/2;  
    6.	    while(left<=right)  
    7.	    {  
    8.	        if(x<ptr[mid])  
    9.	        {  
    10.	            right=mid-1;  
    11.	        }  
    12.	        else if(x>ptr[mid])  
    13.	        {  
    14.	            left=mid+1;  
    15.	        }  
    16.	        else  
    17.	        {  
    18.	            return mid;  
    19.	        }  
    20.	    }  
    21.	    return -1;  
    22.	}  

对于非递归的二分查找与递归查找的时间复杂度一样的分析方法,所以时间复杂度为O(log2^n)；
但是在这个过程中，辅助空间为常数级别，所以空间复杂度为O(1)

# 一般解释：
-----

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。
一个算法在计算机存储器上所占用的存储空间，
包括程序代码所占用的空间，输入数据所占用的空间和辅助变量所占用的空间这三个方面。
算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，
它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，
就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，
而且不随问题规模的大小而改变，我们称这种算法是“就地"进行的，是节省存储的算法，如这些介绍过的几个算法都是如此；
有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，
例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。
    分析一个算法所占用的存储空间要从各方面综合考虑。如对于递归算法来说，一般都比较简短，算法本身所占用的存储空间较少，但运行时需要一个附加堆栈，从而占用较多的临时工作单元；若写成非递归算法，一般可能比较长，算法本身占用的存储空间较多，但运行时将可能需要较少的存储单元。
    一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，它包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。若一个算法为递归算法，其空间复杂度为递归所使用的堆栈空间的大小，它等于一次调用所分配的临时存储空间的大小乘以被调用的次数(即为递归调用的次数加1，这个1表不开始进行的一次非递归调用)。算法的空间复杂度一般也以数量级的形式给出。如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(log2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。
    对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当=i自求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。

 
空间复杂度是程序运行所以需要的额外消耗存储空间,也用o()来表示

　　比如插入排序的时间复杂度是o(n2),空间复杂度是o(1)
　　而一般的递归算法就要有o(n)的空间复杂度了,因为每次递归都要存储返回信息
　　一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量，算法执行时间的度量不是采用算法执行的绝对时间来计算的，因为一个算法在不同的机器上执行所花的时间不一样，在不同时刻也会由于计算机资源占用情况的不同，使得算法在同一台计算机上执行的时间也不一样，所以对于算法的时间复杂性，采用算法执行过程中其基本操作的执行次数，称为计算量来度量。
　　算法中基本操作的执行次数一般是与问题规模有关的，对于结点个数为n的数据处理问题，用T(n)表示算法基本操作的执行次数.在评价算法的时间复杂性时，不考虑两算法执行次数之间的细小区别，而只关心算法的本质差别:
　　为此，引入一个所谓的O() 记号，则T1(n)=2n=O(n),T2(n)=n+1=O(n)。一个函数f(n)是O(g(n))的，则一定存在正常数c和m，使对所有的n>m，都满足f(n)<c*g(n)。

参考：https://www.cnblogs.com/zakers/archive/2015/09/14/4808821.html


  [1]: https://i.loli.net/2018/07/16/5b4ca67c4236e.png