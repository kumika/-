#  1时间复杂度定义：

------

**评估执行程序所需的时间。可以估算出程序对处理器的使用程度。**
设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。

# 2 时间复杂度：
--------

2.1时间频度：
--------

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的**语句执行次数**称为**语句频度**或**时间频度**。记为T(n)。


*什么嘛，这里的频度其实就是数学上的指数，然后在实际中，我们是只设定循环判断的输入变量的初始值和判断范围值，输入变量在经过判断后增加数值的指数是机器计算的，现在我们需要人工估算，进行改进。*



2.2时间复杂度：
---------

时间频度T(n)中，n称为**问题的规模**，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有**某个辅助函数f(n)**，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称**f(n)是T(n)的同数量级函数**，

> 记作T(n)=O(f(n))

，它称为算法的渐进时间复杂度，简称**时间复杂度**。
*T(n) = 循环体运行次数 * （循环体语句频度 + 循环判定语句频度）经验公式？！目前好像感觉不行。先记着*

# 3大o表示法：
-------

前面用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。
算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度。 
大O表示法O(f(n)中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。

3.1推导大O阶
--------

推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法： 
1.用常数1来取代运行时间中所有加法常数。 
2.修改后的运行次数函数中，**只保留最高阶项** 
3.如果***最高阶项存在且不是1，则去除与这个项相乘的常数。***

3.1.1常数阶
--------

      int sum = 0,n = 100; //执行一次  
      sum = (1+n)*n/2; //执行一次  
      System.out.println (sum); //执行一次


上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。如果sum = （1+n）*n/2这条语句再执行10遍，因为这与问题大小n的值并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶

3.1.2线性阶和立方阶
------------

T(n) 或者f(n)  = 循环体运行次数 * （循环体语句频度 + 循环判定语句频度）
下面的例子判断语句都是加减法，所以算1

    例子1 ：
    for(int i=0;i<n;i++){           //循环次数为n
    printf(“faker is mid god!!!”)  //时间复杂度为O(1)的算法
    ...
    }

上面算法循环体中的代码执行了n次，因此时间复杂度为O(n * 1) 即为O(n)。

例子2 ：
对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c...，则这个循环的时间**复杂度为 O(n×a×b×c...)**。分析的时候应该由里向外分析这些循环。

    void aFunc(int n) {
        for(int i = 0; i < n; i++) {         // 循环次数为 n
            for(int j = 0; j < n; j++) {       // 循环次数为 n
                printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
            }
        }
    }

此时时间复杂度为 O(n × n × 1)，即 O(n^2)。


例子3：对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度

    void aFunc(int n) {
        // 第一部分时间复杂度为 O(n^2)
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                printf("Hello, World!\n");
            }
        }
        // 第二部分时间复杂度为 O(n)
        for(int j = 0; j < n; j++) {
            printf("Hello, World!\n");
        }
    }

此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)


例子4：对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度

    void aFunc(int n) {
        if (n >= 0) {
            // 第一条路径时间复杂度为 O(n^2)
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    printf("输入数据大于等于零\n");
                }
            }
        } else {
            // 第二条路径时间复杂度为 O(n)
            for(int j = 0; j < n; j++) {
                printf("输入数据小于零\n");
            }
        }
    }

此时时间复杂度为 **max(O(n^2), O(n))，即 O(n^2)，**
时间复杂度分析的基本策略是**：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析**。


3.1.3对数阶
--------

> T(n) 或者f(n)  = 循环体运行次数 * （循环体语句频度 + 循环判定语句频度）

下面例子的判断语句是乘除法，需要进行算出指数，这个指数就是所需要的时间复杂度
麻蛋，几把例子的输入变量都是在循环体内进行更新，有什么意思
例子1：

    int number=1;
    while(number<n) 
    {
       number=number*2;
    //时间复杂度为O(1)的算法
    ...
    }

可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。
**为什么记做O（log n） ？**
因为：

> 算法的 T(n) = O(log n)，则称其具有**对数时间**。由于计算机使用二进制的记数系统，对数常常以10为底（即log10 n，有时写作
> lg n）。然而，由对数的换底公式，loga n和 logb n只有一个常数因子不同，这个因子在大O记法中被丢弃。因此记作O(log
> n)，而不论对数的底是多少，是对数时间算法的标准记法

另外的解释：假设循环次数为 t，则循环条件满足 2^t < n。
可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。

另外的解释 ：
记得f(n)是辅助函数
number=number*2语句频度是f(n),   
则：2^f(n)<=n;      f(n)<=log2n    
取最大值f(n)=log2n,
T(n)=O(log2n )

3.1.3 其他阶
---------

**f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。 
f(n)=n³时，时间复杂度为O(n³)，可以称为立方阶。 
f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。 
f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。 
f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶。**


# 4 复杂度的比较

n	|	logn |	√n|	nlogn|	n²|	2ⁿ|	n!
- | :-: | -: 
5 |		2|	2|	10|	25|	32|	120
10		|3	|3|	30	|100	|1024|	3628800
50		|5|	7|	250|	2500|	约10^15|	约3.0*10^64
100		|6	|10	|600	|10000|	约10^30	|约9.3*10^157
1000	|	9|	31|	9000|	1000 000	|约10^300	|约4.0*10^2567


从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。


时间1.1图
![时间1.1图][1]
时间1.2图
![时间1.2图][2]

> O(1)< O(logn) < O(n)< O(nlogn)< O(n²)< O(n³)< O(2ⁿ)< O(n!)

指数时间的关系为：
  

>   O(2n) < O(n!) < O(nn)



# 5 而外的例子
T(n) 或者f(n)  = 循环体运行次数 * （循环体语句频度 + 循环判定语句频度）
一定要记得项数前的常量是可以消除的，毕竟是估算

    int num1, num2;
    
    for(int i=0; i<n; i++){ 
    	num1 += 1;
    
    	for(int j=1; j<=n; j*=2){ 
    
    		num2 += num1;
    
    	}
    }


参考：https://www.zhihu.com/question/20503898
for(int j=1; j<=n; j*=2)
这个循环最终执行的次数假设为x，则x次的时候j=2^x 
当j>n时停止执行，于是2^x>n 则可以认为该循环一共执行了log2(n)次
所以该循环的时间复杂度为o(log2(n))简记为o(log n) 忽略掉2的底数

另外的解释：
如果不看循环内执行语句，单单看循环本身的话，这个问题是不是就很好理解。
首先，我们来看外循环for（i=0；i<n；i++），按照i++的递加速度，直到这个循环退出，一共是n次。
再来看看内部循环，for（j=1；j<n;j*=2）,这个内部循环的累加速度是j=j*2，假设循环x次之后，这个循环退出，2^x>n===》x=log(2)N 
ps:(2)代表底数，请原谅我打不出正确的数学符号，sorry
如果把两个循环合在一起看的话，也就是一共循环了n个x次，也就是n*log(2)N

> 递归算法的时间复杂度计算：递归总次数*每次递归次数.

练习题http://c.biancheng.net/cpp/html/2653.html
参考：https://blog.csdn.net/firefly_2002/article/details/8008987

时间2.1图
![时间2.1图][3]
时间2.2图
![时间2.2图][4]



理解好：i+1,i+2 到n ，用长度就好理解了


 


  [1]: https://i.loli.net/2018/07/16/5b4c7fc3732b3.png
  [2]: https://i.loli.net/2018/07/16/5b4c7fc36ff30.png
  [3]: https://i.loli.net/2018/07/16/5b4c7fc37132a.png
  [4]: https://i.loli.net/2018/07/16/5b4c7fc3719e2.png